import { Component, ElementRef, Renderer2, Input, Output, HostListener, EventEmitter, NgModule } from '@angular/core';
import { __assign, __values, __spread } from 'tslib';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TagCloudComponent = /** @class */ (function () {
    function TagCloudComponent(el, r2) {
        this.el = el;
        this.r2 = r2;
        this.clicked = new EventEmitter();
        this.dataChanges = new EventEmitter();
        this.afterInit = new EventEmitter();
        this.afterChecked = new EventEmitter();
        this.alreadyPlacedWords = [];
    }
    /**
     * @param {?} event
     * @return {?}
     */
    TagCloudComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.logMessage('debug', 'rezisze triggered');
        window.clearTimeout(this.timeoutId);
        this.timeoutId = window.setTimeout((/**
         * @return {?}
         */
        function () {
            if (_this.options.realignOnResize) {
                _this.reDraw();
            }
        }), 200);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    TagCloudComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.logMessage('debug', 'ngOnChanges fired', changes);
        // set default values
        this.config = __assign({ width: 500, height: 300, overflow: true, strict: false, zoomOnHover: {
                transitionTime: 0,
                scale: 1,
                delay: 0,
                color: null
            }, realignOnResize: false, randomizeAngle: false, background: null, font: null, step: 2.0, log: false }, this.config // override default width params in config object
        );
        // override properties if explicitly set
        if (this.width) {
            this.config.width = this.width;
        }
        if (this.height) {
            this.config.height = this.height;
        }
        if (typeof this.overflow === 'boolean') {
            this.config.overflow = this.overflow;
        }
        if (typeof this.strict === 'boolean') {
            this.config.strict = this.strict;
        }
        if (typeof this.realignOnResize === 'boolean') {
            this.config.realignOnResize = this.realignOnResize;
        }
        if (typeof this.randomizeAngle === 'boolean') {
            this.config.randomizeAngle = this.randomizeAngle;
        }
        if (typeof this.background === 'string') {
            this.config.background = this.background;
        }
        if (typeof this.font === 'string') {
            this.config.font = this.font;
        }
        if (this.zoomOnHover) {
            this.config.zoomOnHover = this.zoomOnHover;
        }
        if (this.step) {
            this.config.step = this.step;
        }
        if (this.log) {
            this.config.log = this.log;
        }
        this.logMessage('warn', 'cloud configuration', this.config);
        // set the basic font style if property is provided
        if (this.config.font) {
            this.r2.setStyle(this.el.nativeElement, 'font', this.config.font);
        }
        // set a background image if property is provided
        if (this.config.background) {
            this.r2.setStyle(this.el.nativeElement, 'background', this.config.background);
        }
        this.reDraw(changes);
    };
    /**
     * @param {?=} changes
     * @return {?}
     */
    TagCloudComponent.prototype.reDraw = /**
     * @param {?=} changes
     * @return {?}
     */
    function (changes) {
        this.dataChanges.emit(changes);
        this.afterChecked.emit();
        this.logMessage('debug', 'dataChanges emitted');
        this.alreadyPlacedWords = [];
        // check if data is not null or empty
        if (!this.data) {
            console.error('angular-tag-cloud: No data passed. Please pass an Array of CloudData');
            return;
        }
        // values changed, reset cloud
        this.el.nativeElement.innerHTML = '';
        // set value changes
        if (changes && changes.data) {
            this.dataArr = changes.data.currentValue;
        }
        // calculate width and height
        /** @type {?} */
        var width = this.config.width;
        if (this.el.nativeElement.parentNode.offsetWidth > 0
            && width <= 1
            && width > 0) {
            width = this.el.nativeElement.parentNode.offsetWidth * width;
        }
        /** @type {?} */
        var height = this.config.height;
        // set options
        this.options = __assign({}, this.config, { aspectRatio: (width / height), width: width, center: {
                x: (width / 2.0),
                y: (height / 2.0)
            } });
        // set the dimensions
        this.r2.setStyle(this.el.nativeElement, 'width', this.options.width + 'px');
        this.r2.setStyle(this.el.nativeElement, 'height', this.options.height + 'px');
        // draw the cloud
        this.drawWordCloud();
        this.logMessage('debug', 'reDraw finished');
    };
    /**
     * @return {?}
     */
    TagCloudComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.afterInit.emit();
        this.logMessage('debug', 'afterInit emitted');
    };
    /**
     * @return {?}
     */
    TagCloudComponent.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        this.afterChecked.emit();
        this.logMessage('debug', 'afterChecked emitted');
    };
    // helper to generate a descriptive string for an entry to use when sorting alphabetically
    // helper to generate a descriptive string for an entry to use when sorting alphabetically
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    TagCloudComponent.prototype.descriptiveEntry = 
    // helper to generate a descriptive string for an entry to use when sorting alphabetically
    /**
     * @private
     * @param {?} entry
     * @return {?}
     */
    function (entry) {
        /** @type {?} */
        var description = entry.text;
        if (entry.color) {
            description += '-' + entry.color;
        }
        if (entry.external) {
            description += '-' + entry.external;
        }
        if (entry.link) {
            description += '-' + entry.link;
        }
        if (entry.rotate) {
            description += '-' + entry.rotate;
        }
        return description;
    };
    /**
     * @private
     * @return {?}
     */
    TagCloudComponent.prototype.drawWordCloud = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // Sort alphabetically to ensure that, all things being equal, words are placed uniformly
        this.dataArr.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function (a, b) { return (_this.descriptiveEntry(a)).localeCompare(_this.descriptiveEntry(b)); }));
        // Sort this._dataArr from the word with the highest weight to the one with the lowest
        this.dataArr.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function (a, b) { return b.weight - a.weight; }));
        this.dataArr.forEach((/**
         * @param {?} elem
         * @param {?} index
         * @return {?}
         */
        function (elem, index) {
            _this.drawWord(index, elem);
        }));
    };
    // Helper function to test if an element overlaps others
    // Helper function to test if an element overlaps others
    /**
     * @private
     * @param {?} testEl
     * @return {?}
     */
    TagCloudComponent.prototype.hitTest = 
    // Helper function to test if an element overlaps others
    /**
     * @private
     * @param {?} testEl
     * @return {?}
     */
    function (testEl) {
        var e_1, _a;
        try {
            // Check elements for overlap one by one, stop and return false as soon as an overlap is found
            for (var _b = __values(this.alreadyPlacedWords), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                if (this.overlapping(testEl, item)) {
                    return true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    };
    // Pairwise overlap detection
    // Pairwise overlap detection
    /**
     * @private
     * @param {?} e1
     * @param {?} e2
     * @return {?}
     */
    TagCloudComponent.prototype.overlapping = 
    // Pairwise overlap detection
    /**
     * @private
     * @param {?} e1
     * @param {?} e2
     * @return {?}
     */
    function (e1, e2) {
        /** @type {?} */
        var rect1 = e1.getBoundingClientRect();
        /** @type {?} */
        var rect2 = e2.getBoundingClientRect();
        /** @type {?} */
        var overlap = !(rect1.right < rect2.left ||
            rect1.left > rect2.right ||
            rect1.bottom < rect2.top ||
            rect1.top > rect2.bottom);
        return overlap;
    };
    // Function to draw a word, by moving it in spiral until it finds a suitable empty place. This will be iterated on each word.
    // Function to draw a word, by moving it in spiral until it finds a suitable empty place. This will be iterated on each word.
    /**
     * @private
     * @param {?} index
     * @param {?} word
     * @return {?}
     */
    TagCloudComponent.prototype.drawWord = 
    // Function to draw a word, by moving it in spiral until it finds a suitable empty place. This will be iterated on each word.
    /**
     * @private
     * @param {?} index
     * @param {?} word
     * @return {?}
     */
    function (index, word) {
        var _this = this;
        // Define the ID attribute of the span that will wrap the word
        /** @type {?} */
        var angle = this.options.randomizeAngle ? 6.28 * Math.random() : 0;
        /** @type {?} */
        var radius = 0;
        /** @type {?} */
        var weight = 5;
        /** @type {?} */
        var wordSpan;
        // Check if min(weight) > max(weight) otherwise use default
        if (this.dataArr[0].weight > this.dataArr[this.dataArr.length - 1].weight) {
            // check if strict mode is active
            if (!this.options.strict) { // Linearly map the original weight to a discrete scale from 1 to 10
                weight = Math.round((word.weight - this.dataArr[this.dataArr.length - 1].weight) /
                    (this.dataArr[0].weight - this.dataArr[this.dataArr.length - 1].weight) * 9.0) + 1;
            }
            else { // use given value for weigth directly
                // fallback to 10
                if (word.weight > 10) {
                    weight = 10;
                    this.logMessage('warn', "[TagCloud strict] Weight property " + word.weight + " > 10. Fallback to 10 as you are using strict mode", word);
                }
                else if (word.weight < 1) { // fallback to 1
                    weight = 1;
                    this.logMessage('warn', "[TagCloud strict] Given weight property " + word.weight + " < 1. Fallback to 1 as you are using strict mode", word);
                }
                else if (word.weight % 1 !== 0) { // round if given value is not an integer
                    weight = Math.round(word.weight);
                    this.logMessage('warn', "[TagCloud strict] Given weight property " + word.weight + " is not an integer. Rounded value to " + weight, word);
                }
                else {
                    weight = word.weight;
                }
            }
        }
        // Create a new span and insert node.
        wordSpan = this.r2.createElement('span');
        wordSpan.className = 'w' + weight;
        /** @type {?} */
        var thatClicked = this.clicked;
        wordSpan.onclick = (/**
         * @return {?}
         */
        function () {
            thatClicked.emit(word);
        });
        /** @type {?} */
        var node = this.r2.createText(word.text);
        // set color
        if (word.color) {
            this.r2.setStyle(wordSpan, 'color', word.color);
        }
        /** @type {?} */
        var transformString = '';
        // set color
        if (word.rotate) {
            transformString = "rotate(" + word.rotate + "deg)";
            this.r2.setStyle(wordSpan, 'transform', transformString);
        }
        // Append href if there's a link alongwith the tag
        if (word.link) {
            /** @type {?} */
            var wordLink = this.r2.createElement('a');
            wordLink.href = word.link;
            if (word.external !== undefined && word.external) {
                wordLink.target = '_blank';
            }
            wordLink.appendChild(node);
            node = wordLink;
        }
        // set zoomOption
        if (this.options.zoomOnHover && this.options.zoomOnHover.scale !== 1) {
            if (!this.options.zoomOnHover.transitionTime) {
                this.options.zoomOnHover.transitionTime = 0;
            }
            if (!this.options.zoomOnHover.scale) {
                this.options.zoomOnHover.scale = 1;
            }
            wordSpan.onmouseover = (/**
             * @return {?}
             */
            function () {
                _this.r2.setStyle(wordSpan, 'transition', "transform " + _this.options.zoomOnHover.transitionTime + "s");
                _this.r2.setStyle(wordSpan, 'transform', "scale(" + _this.options.zoomOnHover.scale + ") " + transformString);
                _this.r2.setStyle(wordSpan, 'transition-delay', _this.options.zoomOnHover.delay + "s");
                if (_this.options.zoomOnHover.color) {
                    word.link
                        ? _this.r2.setStyle(node, 'color', _this.options.zoomOnHover.color)
                        : _this.r2.setStyle(wordSpan, 'color', _this.options.zoomOnHover.color);
                }
            });
            wordSpan.onmouseout = (/**
             * @return {?}
             */
            function () {
                _this.r2.setStyle(wordSpan, 'transform', "none " + transformString);
                word.link
                    ? _this.r2.removeStyle(node, 'color')
                    : _this.r2.removeStyle(wordSpan, 'color');
            });
        }
        wordSpan.appendChild(node);
        this.r2.appendChild(this.el.nativeElement, wordSpan);
        /** @type {?} */
        var width = wordSpan.offsetWidth;
        /** @type {?} */
        var height = wordSpan.offsetHeight;
        /** @type {?} */
        var left = this.options.center.x - (width / 2);
        /** @type {?} */
        var top = this.options.center.y - (height / 2);
        // Save a reference to the style property, for better performance
        /** @type {?} */
        var wordStyle = wordSpan.style;
        wordStyle.position = 'absolute';
        // place the first word
        wordStyle.left = left + 'px';
        wordStyle.top = top + 'px';
        // add tooltip if provided
        if (word.tooltip) {
            this.r2.addClass(wordSpan, 'tooltip');
            /** @type {?} */
            var tooltipSpan = this.r2.createElement('span');
            tooltipSpan.className = 'tooltiptext';
            /** @type {?} */
            var text = this.r2.createText(word.tooltip);
            tooltipSpan.appendChild(text);
            wordSpan.appendChild(tooltipSpan);
        }
        // set a unique id
        wordSpan.id = "angular-tag-cloud-item-" + index;
        while (this.hitTest(wordSpan)) {
            radius += this.options.step;
            angle += (index % 2 === 0 ? 1 : -1) * this.options.step;
            left = this.options.center.x - (width / 2.0) + (radius * Math.cos(angle)) * this.options.aspectRatio;
            top = this.options.center.y + radius * Math.sin(angle) - (height / 2.0);
            wordStyle.left = left + 'px';
            wordStyle.top = top + 'px';
        }
        // do not place the first word always right in the middle
        if (index === 0) {
            wordStyle.left = left + ((Math.random() - 0.5) * 2) * (this.options.width / 5) + 'px';
            wordStyle.top = top + ((Math.random() - 0.5) * 2) * (this.options.height / 5) + '30px';
        }
        // Don't render word if part of it would be outside the container
        if (!this.options.overflow &&
            (left < 0 || top < 0 || (left + width) > this.options.width ||
                (top + height) > this.options.height)) {
            this.logMessage('warn', 'Word did not fit into the cloud and overflow is set to \'false\'. The element will be removed', wordSpan);
            wordSpan.remove();
            return;
        }
        this.logMessage('debug', 'Adds new word <span>', wordSpan);
        this.alreadyPlacedWords.push(wordSpan);
        this.logMessage('debug', 'Placed words', this.alreadyPlacedWords);
    };
    /**
     * @private
     * @param {?} level
     * @param {...?} args
     * @return {?}
     */
    TagCloudComponent.prototype.logMessage = /**
     * @private
     * @param {?} level
     * @param {...?} args
     * @return {?}
     */
    function (level) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (!this.config) {
            return;
        }
        if (this.config.log === 'debug') {
            console.log.apply(console, __spread(["[AngularTagCloudModule " + level + "]"], args));
        }
        else if (this.config.log === 'warn' && level === 'warn') {
            console.warn.apply(console, __spread(["[AngularTagCloudModule " + level + "]"], args));
        }
    };
    TagCloudComponent.decorators = [
        { type: Component, args: [{
                    selector: 'angular-tag-cloud, ng-tag-cloud, ngtc',
                    template: '',
                    styles: [":host{font-family:Helvetica,Arial,sans-serif;font-size:10px;line-height:normal;color:#09f;overflow:hidden;position:relative;display:block}span{padding:0}span.w10{font-size:550%}span.w9{font-size:500%}span.w8{font-size:450%}span.w7{font-size:400%}span.w6{font-size:350%}span.w5{font-size:300%}span.w4{font-size:250%}span.w3{font-size:200%}span.w2{font-size:150%}a:hover,span.w10,span.w8,span.w9{color:#0cf}span.w7{color:#39d}span.w6{color:#90c5f0}span.w5{color:#90a0dd}span.w4{color:#90c5f0}span.w3{color:#a0ddff}span.w2{color:#9ce}span.w1{font-size:100%;color:#aab5f0}.tooltip .tooltiptext{visibility:hidden;width:inherit;background-color:#555;color:#fff;text-align:center;border-radius:6px;padding:5px 10px;position:absolute;bottom:100%;left:0;opacity:0;transition:opacity .3s}.tooltip .tooltiptext::after{content:\"\";position:absolute;top:100%;left:50%;margin-left:-5px;border-width:5px;border-style:solid;border-color:#555 transparent transparent}.tooltip:hover .tooltiptext{visibility:visible;opacity:1}"]
                }] }
    ];
    /** @nocollapse */
    TagCloudComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    TagCloudComponent.propDecorators = {
        data: [{ type: Input }],
        width: [{ type: Input }],
        height: [{ type: Input }],
        step: [{ type: Input }],
        overflow: [{ type: Input }],
        strict: [{ type: Input }],
        zoomOnHover: [{ type: Input }],
        realignOnResize: [{ type: Input }],
        randomizeAngle: [{ type: Input }],
        background: [{ type: Input }],
        font: [{ type: Input }],
        config: [{ type: Input }],
        log: [{ type: Input }],
        clicked: [{ type: Output }],
        dataChanges: [{ type: Output }],
        afterInit: [{ type: Output }],
        afterChecked: [{ type: Output }],
        onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
    };
    return TagCloudComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TagCloudModule = /** @class */ (function () {
    function TagCloudModule() {
    }
    TagCloudModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [TagCloudComponent],
                    exports: [TagCloudComponent],
                    entryComponents: [TagCloudComponent]
                },] }
    ];
    return TagCloudModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { TagCloudComponent, TagCloudModule };
//# sourceMappingURL=angular-tag-cloud-module.js.map
